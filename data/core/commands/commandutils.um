import (
	"std.um"
	"strings.um"
	"config.um"
	"env.um"
	"command.um"
	"cex.um"
	"logview.um"
	"system.um"
	"common.um"
	"commandview.um"
	"rootview.um"
	"translate.um"
	"docview.um"
	"search.um"
	"doc.um"
	"style.um"
	"keymap.um"
)

fn has_commandview(): bool {
	switch v := type(cex::active_view) {
		case commandview::CommandView: return true
	}
	return false
}

fn has_docview(): bool {
	switch v := type(cex::active_view) {
		case docview::DocView: return true
	}
	return false
}

fn is_docview(view: cex::View): bool {
	switch v := type(view) {
		case docview::DocView: return true
	}
	return false
}

fn doc(): ^doc::Doc {
	switch v := type(cex::active_view) {
		case ^docview::DocView: return v.doc
		case ^commandview::CommandView: return v.doc
	}
	return null
}

fn has_doc(): bool {
	switch v := type(cex::active_view) {
		case ^docview::DocView: return true
		case ^commandview::CommandView: return true
	}
	return false
}

fn cv(v: cex::View): ^commandview::CommandView { return ^commandview::CommandView(v) }
fn dv(v: cex::View): ^docview::DocView { return ^docview::DocView(v) }
fn rv(v: cex::View): ^rootview::RootView { return ^rootview::RootView(v) }
// fn sv(v: cex::View): ^statusview::StatusView { return ^statusview::StatusView(v) }
// fn lv(v: cex::View): ^logview::LogView { return ^logview::LogView(v) }

fn load_commands_command() {
	command::add(has_commandview, {
		"command:submit": fn() { cv(cex::active_view).submit() },
		"command:complete": fn() { cv(cex::active_view).complete() },
		"command:escape": fn() { cv(cex::active_view).exit() },
		"command:select-previous": fn() { cv(cex::active_view).move_suggestion_idx(1) },
		"command:select-next": fn() { cv(cex::active_view).move_suggestion_idx(-1) },
	})
}

fullscreen := false

fn suggest_default(_: str): []cex::Suggestion { return {} }
fn cancel_default(_: bool) {}

fn count_dirty_docs*(): (int, str) {
	dirty_count := 0
	var dirty_name: str 
	for _, d in cex::docs {
		doc := ^doc::Doc(d)
		if doc.is_dirty() {
			dirty_count = dirty_count + 1
			dirty_name = doc.get_name()
		}
	}
	return dirty_count, dirty_name
}

fn quit*(force: bool = false) {
	if force {
		cex::delete_temp_files()
		cex::quit_request = true
		return
	}
	dirty_count, dirty_name := count_dirty_docs()
	if dirty_count > 0 {
		var text: str
		if dirty_count == 1 {
			text = sprintf("\"%s\" has unsaved changes. Quit anyway?", dirty_name)
		} else {
			text = sprintf("%d docs have unsaved changes. Quit anyway?", dirty_count)
		}
		confirm := system::show_confirm_dialog("Unsaved Changes", text)
		if !confirm { return }
	}
	quit(true)
}

fn open_doc*(filename: str = ""): ^doc::Doc {
	if len(filename) > 0 {
		//   -- try to find existing doc for filename
		abs_filename := system::absolute_path(filename).item0
		for _, d in cex::docs {
			doc := ^doc::Doc(d)
			if len(doc.filename) > 0 && abs_filename == system::absolute_path(doc.filename).item0 {
				return doc
			}
		}
	}
	// -- no existing doc for filename; create new
	doc := doc::get_new(filename)
	cex::docs = append(cex::docs, doc)
	if len(filename) > 0 {
		cex::log_quiet(sprintf("Opened doc \"%s\"", filename))
	} else {
		cex::log_quiet("Opened new Doc")
	}
	return doc
}

fn load_commands_core() {
	command::add(command::always_true, {
		"core:quit": fn() { quit() },
		"core:force-quit": fn() { quit(true) },
		"core:toggle-fullscreen": fn() {
			fullscreen = !fullscreen
			system::set_window_mode((fullscreen ? "fullscreen" : "normal"))
		},
		"core:find-command": fn() {
			commands := command::get_all_valid()
			submit := fn(text: str, item: ^cex::Suggestion) {
				if item != null {
					command::perform(item.command)
				}
			}
			suggest := fn(text: str): []cex::Suggestion |commands| {
				matches := common::fuzzy_match(commands, text)
				res := make([]cex::Suggestion, len(matches))
				for i, name in matches {
					res[i] = {
						text: command::prettify_name(name),
						info: keymap::get_binding(name),
						command: name,
					}
				}
				return res
			}
			cv(cex::command_view).enter("Do Command", submit, suggest, cancel_default)
		},

		"core:find-file": fn() {
			submit := fn(text: str, item: ^cex::Suggestion) {
				text = (item != null)? item.text : text
				rv(cex::root_view).open_doc(open_doc(text))
			}
			suggest := fn(text: str): []cex::Suggestion {
				files := make([]str, 0)
				for _, item in cex::project_files {
					if !item.is_dir {
						files = append(files, item.name)
					}
				}
				matches := common::fuzzy_match(files, text)
				res := make([]cex::Suggestion, len(matches))
				for i in matches {
					res[i] = {text: matches[i]}
				}
				return res
			}
			cv(cex::command_view).enter("Open File From Project", submit, suggest, cancel_default)
		},

		"core:new-doc": fn() {
			rv(cex::root_view).open_doc(open_doc())
		},

		"core:open-file": fn() {
			submit := fn(text: str, _: ^cex::Suggestion) {
				rv(cex::root_view).open_doc(open_doc(text))
			}
			suggest := fn(text: str): []cex::Suggestion {
				matches := common::path_suggest(text)
				res := make([]cex::Suggestion, len(matches))
				for i in matches {
					res[i] = {text: matches[i]}
				}
				return res
			}
			cv(cex::command_view).enter("Open File", submit, suggest, cancel_default)
		},

		"core:open-log": fn() {
			node := rv(cex::root_view).get_active_node()
			node.add_view(logview::get_new())
		},

		"core:open-user-module": fn() {
			rv(cex::root_view).open_doc(open_doc(env::EXEDIR + "/data/user/init.um"))
		},

		"core:open-project-module": fn() {
			filename := ".lite_project.um"
			if system::get_file_info(filename).item1 {
				rv(cex::root_view).open_doc(open_doc(filename))
			} else {
				doc := open_doc()
				rv(cex::root_view).open_doc(doc)
				doc.save(filename)
			}
		},
	})
}

fn get_indent_string(): str {
	if config::tab_type == "hard" {
		return "\t"
	}
	return strings::rep(" ", config::indent_size)
}

fn insert_at_start_of_selected_lines(text: str, skip_empty: bool = false) {
	sel, swap := doc().get_selection(true)
	for line := sel.a.line; line<=sel.b.line; line++ {
		line_text := doc().lines[line]
		if !skip_empty || strings::find(line_text, "%S").item2 {
			doc().insert(line, 0, text)
		}
	}
	doc().set_selection(sel.a.line, sel.a.col + len(text), sel.b.line, sel.b.col + len(text), swap)
}

fn remove_from_start_of_selected_lines(text: str, skip_empty: bool = false) {
	sel, swap := doc().get_selection(true)
	line1, col1, line2, col2 := sel.a.line, sel.a.col, sel.b.line, sel.b.col
	for line := line1; line<=line2; line++ {
		line_text := doc().lines[line]
		if slice(line_text, 0, len(text)) == text && (!skip_empty || strings::find(line_text, "%S").item2) {
			doc().remove(line, 0, line, len(text))
		}
	}
	doc().set_selection(line1, col1 - len(text), line2, col2 - len(text), swap)
}

fn append_line_if_last_line(line: int) {
	if line >= len(doc().lines) {
		doc().insert(line, env::INT_MAX, "\n")
	}
}

fn save(filename: str = "") {
	doc().save(filename)
	cex::log_info(sprintf("Saved \"%s\"", doc().filename))
}

var gtl_items: struct {
	items: []cex::Suggestion;
	doc: ^doc::Doc;
}

fn gtl_init_items() {
	d := doc()
	if gtl_items.doc == d {
		return 
	}
	gtl_items = {}
	gtl_items.doc = d
	for i, line in d.lines {
		gtl_items.items = append(gtl_items.items, {
			text: slice(line, 0, len(line)-1),
			line: i+1,
			info: "line: " + std::itoa(i+1),
		})
	}
}

fn fuzzy_match_suggestions(items: []cex::Suggestion, needle: str): []cex::Suggestion {
	scores := make([]common::Pair, 0)
	for i, haystack in items {
		s, ok := system::fuzzy_match(haystack.text, needle)
		if ok {
			scores = append(scores, {s, i})
		}
	}
	sort(scores, false, score)
	res := make([]cex::Suggestion, len(scores))
	for i, p in scores {
		res[i] = items[p.index]
	}
	return res
}

fn load_commands_doc() {
	commands := map[str]fn(){
		"doc:undo": fn () {	doc().undo() },
		"doc:redo": fn () { doc().redo() },
		"doc:cut": fn () {
			doc := doc()
			if doc.has_selection() {
				text := doc.get_text_sel(doc.get_selection().item0)
				system::set_clipboard(text)
				doc.delete_to(doc::noop, 0)
			}
		},
		"doc:copy": fn () {
			doc := doc()
			if doc.has_selection() {
				text := doc.get_text_sel(doc.get_selection().item0)
				system::set_clipboard(text)
			}
		},
		"doc:paste": fn () {
			doc().text_input(strings::gsub(system::get_clipboard(), "\r", ""))
		},
		"doc:newline": fn () {
			sel := doc().get_selection().item0
			line, col := sel.a.line, sel.a.col
			matches := strings::match(doc().lines[line], "^[\t ]*")
			indent := (len(matches) > 0)? matches[0] : ""
			if len(indent) > 0 && col <= len(indent) {
				indent = slice(indent, len(indent) + 2 - col)
			}
			doc().text_input("\n" + indent)
		},
		"doc:newline-below": fn () {
			sel := doc().get_selection().item0
			line := sel.a.line
			matches := strings::match(doc().lines[line], "^[\t ]*")
			indent := (len(matches) > 0)? matches[0] : ""
			doc().insert(line, env::INT_MAX, "\n" + indent)
			doc().set_selection(line + 1, env::INT_MAX)
		},
		"doc:newline-above": fn () {
			sel := doc().get_selection().item0
			line := sel.a.line
			matches := strings::match(doc().lines[line], "^[\t ]*")
			indent := (len(matches) > 0)? matches[0] : ""
			doc().insert(line, 0, indent + "\n")
			doc().set_selection(line, env::INT_MAX)
		},
		"doc:delete": fn () {
			sel := doc().get_selection().item0
			line, col := sel.a.line, sel.a.col
			if !doc().has_selection() && strings::find(doc().lines[line], "^%s*$", col).item2 {
					doc().remove(line, col, line, env::INT_MAX)
			}
			doc().delete_to(translate::next_char)
		},
		"doc:backspace": fn () {
			sel := doc().get_selection().item0
			line, col := sel.a.line, sel.a.col
			if !doc().has_selection() {
				text := doc().get_text(line, 0, line, col)
				if len(text) >= config::indent_size && strings::find(text, "^ *$").item2 {
					doc().delete_to(doc::noop, 0, -config::indent_size)
					return
				}
			}
			doc().delete_to(translate::previous_char)
		},
		"doc:select-all": fn () {
			doc().set_selection(0, 0, env::INT_MAX, env::INT_MAX)
		},
		"doc:select-none": fn () {
			sel := doc().get_selection().item0
			line, col := sel.a.line, sel.a.col
			doc().set_selection(line, col)
		},
		"doc:select-lines": fn () {
			sel, swap := doc().get_selection(true)
			line1, line2 := sel.a.line, sel.b.line
			append_line_if_last_line(line2)
			doc().set_selection(line1, 0, line2 + 1, 0, swap)
		},
		"doc:select-word": fn () {
			sel := doc().get_selection(true).item0
			line1, col1 := sel.a.line, sel.a.col
			line1, col1 = translate::start_of_word(doc(), line1, col1)
			line2, col2 := translate::end_of_word(doc(), line1, col1)
			doc().set_selection(line2, col2, line1, col1)
		},
		"doc:join-lines": fn () {
			sel := doc().get_selection(true).item0
			line1, line2 := sel.a.line, sel.b.line
			if line1 == line2 { line2 = line2 + 1 }
			text := doc().get_text(line1, 0, line2, env::INT_MAX)
			text = strings::gsub_fn(text, "(.-)\n[\t ]*", fn (x: str): str {
					return strings::find(x, "^%s*$").item2 ? x : x + " "
			}, 1)
			doc().insert(line1, 0, text)
			doc().remove(line1, len(text) + 1, line2, env::INT_MAX)
			if doc().has_selection() {
				doc().set_selection(line1, env::INT_MAX)
			}
		},
		"doc:indent": fn () {
			text := get_indent_string()
			if doc().has_selection() {
				insert_at_start_of_selected_lines(text)
			} else {
				doc().text_input(text)
			}
		},
		"doc:unindent": fn () {
			text := get_indent_string()
			remove_from_start_of_selected_lines(text)
		},
		"doc:duplicate-lines": fn () {
			sel, swap := doc().get_selection(true)
			line1, col1, line2, col2 := sel.a.line, sel.a.col, sel.b.line, sel.b.col
			append_line_if_last_line(line2)
			text := doc().get_text(line1, 0, line2 + 1, 0)
			doc().insert(line2 + 1, 0, text)
			n := line2 - line1 + 1
			doc().set_selection(line1 + n, col1, line2 + n, col2, swap)
		},
		"doc:delete-lines": fn () {
			sel := doc().get_selection(true).item0
			line1, col1, line2 := sel.a.line, sel.a.col, sel.b.line
			append_line_if_last_line(line2)
			doc().remove(line1, 0, line2 + 1, 0)
			doc().set_selection(line1, col1)
		},
		"doc:move-lines-up": fn () {
			sel, swap := doc().get_selection(true)
			line1, col1, line2, col2 := sel.a.line, sel.a.col, sel.b.line, sel.b.col
			append_line_if_last_line(line2)
			if line1 > 1 {
				text := doc().lines[line1 - 1]
				doc().insert(line2 + 1, 0, text)
				doc().remove(line1 - 1, 0, line1, 0)
				doc().set_selection(line1 - 1, col1, line2 - 1, col2, swap)
			}
		},
		"doc:move-lines-down": fn () {
			sel, swap := doc().get_selection(true)
			line1, col1, line2, col2 := sel.a.line, sel.a.col, sel.b.line, sel.b.col
			append_line_if_last_line(line2 + 1)
			if line2 < len(doc().lines)-1 {
				text := doc().lines[line2 + 1]
				doc().remove(line2 + 1, 0, line2 + 2, 0)
				doc().insert(line1, 0, text)
				doc().set_selection(line1 + 1, col1, line2 + 1, col2, swap)
			}
		},
		"doc:toggle-line-comments": fn () {
			comment := doc().syntax.comment
			if len(comment) == 0 { return }
			comment_text := comment + " "
			sel := doc().get_selection(true).item0
			line1, line2 := sel.a.line, sel.b.line
			uncomment := true
			for line := line1; line <= line2; line++ {
				text := doc().lines[line]
				if strings::find(text, "%S").item2 && strings::find(text, comment_text, 0, true).item0 != 0 {
						uncomment = false
				 }
			}
			if uncomment {
				remove_from_start_of_selected_lines(comment_text, true)
			} else {
				insert_at_start_of_selected_lines(comment_text, true)
			}
		},
		"doc:upper-case": fn () {
			doc().replace(fn(s: str): (str, int) { return strings::upper(s), len(s) })
		},
		"doc:lower-case": fn () {
			doc().replace(fn(s: str): (str, int) { return strings::lower(s), len(s) })
		},
		"doc:go-to-line": fn () {
			gtl_items = {}
			submit := fn(text: str, item: ^cex::Suggestion) {
				var line: int
				if item != null {
					line = item.line
				} else {
					if strings::find(text, "^%d*$").item2 {
						line = std::atoi(text)
					} else {
						cex::log_error("invalid line number or unmatched string")
						return
					}
				}
				dv(cex::active_view).doc.set_selection(line-1, 0)
				dv(cex::active_view).scroll_to_line(line-1, true)
			}
			suggest := fn(text: str): []cex::Suggestion {
				if !strings::find(text, "^%d*$").item2 {
					gtl_init_items()
					return fuzzy_match_suggestions(gtl_items.items, text)
				}
				return {}
			}
			cv(cex::command_view).enter("Go To Line", submit, suggest, cancel_default)
		},
		"doc:toggle-line-ending": fn () { doc().crlf = !doc().crlf },
		"doc:save-as": fn () {
			if len(doc().filename) > 0 {
				cv(cex::command_view).set_text(doc().filename)
			}
			suggest := fn(text: str): []cex::Suggestion {
				matches := common::path_suggest(text)
				res := make([]cex::Suggestion, len(matches))
				for i in matches {
					res[i] = {text: matches[i]}
				}
				return res
			}
			cv(cex::command_view).enter("Save As", fn (filename: str, _: ^cex::Suggestion) {
					save(filename)
			}, suggest, cancel_default)
		},
		"doc:save": fn () {
			if len(doc().filename) > 0 {
				save()
			} else {
				command::perform("doc:save-as")
			}
		},
		"doc:rename": fn () {
			old_filename := doc().filename
			if len(old_filename) == 0 {
					cex::log_error("Cannot rename unsaved doc")
					return
			}
			cv(cex::command_view).set_text(old_filename)
			submit := fn(filename: str, _: ^cex::Suggestion) |old_filename| {
				doc().save(filename)
				cex::log_info(sprintf("Renamed \"%s\" to \"%s\"", old_filename, filename))
				if filename != old_filename {
					std::remove(old_filename)
				}
			}
			suggest := fn(text: str): []cex::Suggestion {
				matches := common::path_suggest(text)
				res := make([]cex::Suggestion, len(matches))
				for i in matches {
					res[i] = {text: matches[i]}
				}
				return res
			}
			cv(cex::command_view).enter("Rename", submit, suggest, cancel_default)
		}
	}


	translations := map[str]doc::TranslateFunc{
		"previous-char": translate::previous_char,
		"next-char": translate::next_char,
		"previous-word-start": translate::previous_word_start,
		"next-word-end": translate::next_word_end,
		"previous-block-start": translate::previous_block_start,
		"next-block-end": translate::next_block_end,
		"start-of-doc": translate::start_of_doc,
		"end-of-doc": translate::end_of_doc,
		"start-of-line": translate::start_of_line,
		"end-of-line": translate::end_of_line,
		"start-of-word": translate::start_of_word,
		"end-of-word": translate::end_of_word,
		"previous-line": fn(d: ^doc::Doc, l, c: int): (int, int) {
			return docview::translate_previous_line(d, l, c, dv(cex::active_view))
		},
		"next-line": fn(d: ^doc::Doc, l, c: int): (int, int) {
			return docview::translate_next_line(d, l, c, dv(cex::active_view))
		},
		"previous-page": fn(d: ^doc::Doc, l, c: int): (int, int) {
			return docview::translate_previous_page(d, l, c, dv(cex::active_view))
		},
		"next-page": fn(d: ^doc::Doc, l, c: int): (int, int) {
			return docview::translate_next_page(d, l, c, dv(cex::active_view))
		},
	}

	for _, name in keys(translations) {
		f := translations[name]
		commands["doc:move-to-" + name] = fn () |f| { doc().move_to(f) }
		commands["doc:select-to-" + name] = fn () |f| { doc().select_to(f) }
		commands["doc:delete-to-" + name] = fn () |f| { doc().delete_to(f) }
	}

	commands["doc:move-to-previous-char"] = fn () {
		if doc().has_selection() {
			sel := doc().get_selection(true).item0
			line, col := sel.a.line, sel.a.col
			doc().set_selection(line, col)
		} else {
			doc().move_to(translate::previous_char)
		}
	}

	commands["doc:move-to-next-char"] = fn () {
		if doc().has_selection() {
			sel := doc().get_selection(true).item0
			line, col := sel.b.line, sel.b.col
			doc().set_selection(line, col)
		} else {
			doc().move_to(translate::next_char)
		}
	}

	command::add(has_doc, commands)
}

max_previous_finds := 50

type SearchFunc = fn(d: ^doc::Doc, l,c: int, text: str): (doc::Selection, bool)

var (
	previous_finds: []doc::Selection
	last_doc: ^doc::Doc
	last_fn: SearchFunc
	last_text: str
)

fn push_previous_find(cdoc: ^doc::Doc, sel: doc::Selection, ok: bool) {
	if last_doc != cdoc {
		last_doc = cdoc
		previous_finds = {}
	}
	if len(previous_finds) >= max_previous_finds {
		previous_finds = delete(previous_finds, 0)
	}
	if !ok {
		sel = doc().get_selection().item0
	}
	previous_finds = insert(previous_finds, 0, sel)
}

fn find_submit_found(dv: ^docview::DocView, search_fn: SearchFunc, text: str, sel: doc::Selection) {
	last_fn, last_text = search_fn, text
	previous_finds = {}
	push_previous_find(dv.doc, sel, true)
}

fn find(label: str, search_fn: SearchFunc) {
	dv := dv(cex::active_view)
	sel := dv.doc.get_selection().item0
	text := dv.doc.get_text(sel.a.line, sel.a.col, sel.b.line, sel.b.col)

	cv(cex::command_view).set_text(text, true)
	submit := fn(text: str, found: ^cex::Suggestion) |search_fn, dv, sel| {
		if found != null {
			find_submit_found(dv, search_fn, text, sel)
		} else {
			cex::log_error("Couldn't find " + text)
			dv.doc.set_selection(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
			dv.scroll_to_make_visible(sel.a.line, sel.a.col)
		}
	}
	suggest := fn (text: str): []cex::Suggestion |search_fn, dv, sel| {
		var ok: bool
		sel, ok = search_fn(dv.doc, sel.a.line, sel.a.col, text)
		if ok && text != "" {
			dv.doc.set_selection(sel.b.line, sel.b.col, sel.a.line, sel.a.col)
			dv.scroll_to_line(sel.b.line, true)
			return {{text: sprintf("Line: %d", sel.b.line)}}
		} else {
			dv.doc.set_selection(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
		}
		return {}
	}
	cancel := fn (explicit: bool) |dv, sel| {
		if explicit {
			dv.doc.set_selection(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
			dv.scroll_to_make_visible(sel.a.line, sel.a.col)
		}
	}
	cv(cex::command_view).enter(label, submit, suggest, cancel)
}


fn replace(kind, def: str, f: fn(t,o,n: str): (str, int)) {
	cv(cex::command_view).set_text(def, true)
	cv(cex::command_view).enter("Find To Replace " + kind, fn (old: str, _: ^cex::Suggestion) |kind, f| {
		cv(cex::command_view).set_text(old, true)
		s := sprintf("Replace %s %s With", kind, old)
		cv(cex::command_view).enter(s, fn (newtext: str, _: ^cex::Suggestion) |kind, f, old| {
			n := doc().replace(fn (text: str): (str, int) |f, old, newtext| {
				return f(text, old, newtext)
			})
			cex::log_info(sprintf("Replaced %d instance(s) of %s %v with %v", n, kind, old, newtext))
		}, suggest_default, cancel_default)
	}, suggest_default, cancel_default)
}

fn has_selection(): bool {
	return has_docview() && doc().has_selection()
}

fn replace_repeat_find() {
	if !valid(last_fn) {
		cex::log_error("No find to continue from")
	} else {
		sel := doc().get_selection().item0
		var ok: bool
		sel, ok = last_fn(doc(), sel.a.line, sel.a.col, last_text)
		if ok {
			push_previous_find(doc(), {}, false)
			doc().set_selection(sel.b.line, sel.b.col, sel.a.line, sel.a.col)
			dv(cex::active_view).scroll_to_line(sel.b.line, true)
		}
	}
}
fn load_commands_find_replace*() {
	command::add(has_selection, {
		"find-replace:select-next": fn() {
			sel := doc().get_selection(true).item0
			text := doc().get_text(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
			var ok: bool
			sel, ok = search::find(doc(), sel.b.line, sel.b.col, text, { wrap: true })
			if ok { doc().set_selection(sel.b.line, sel.b.col, sel.a.line, sel.a.col) }
		}
	})

	command::add(has_docview, {
		"find-replace:find": fn() {
			find("Find Text", fn (doc: ^doc::Doc, line, col: int, text: str): (doc::Selection, bool) {
				return search::find(doc, line, col, text, {wrap: true, no_case: true})
			})
		},
		"find-replace:find-pattern": fn() {
			find("Find Text Pattern", fn (doc: ^doc::Doc, line, col: int, text: str): (doc::Selection, bool) {
				return search::find(doc, line, col, text, { wrap: true, no_case: true, pattern: true })
			})
		},
		"find-replace:repeat-find": replace_repeat_find,
		"find-replace:previous-find": fn() {
			if len(previous_finds) == 0 || doc() != last_doc {
				cex::log_error("No previous finds")
				return
			}
			sel := previous_finds[len(previous_finds)-1]
			previous_finds = delete(previous_finds, len(previous_finds)-1)
			doc().set_selection(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
			dv(cex::active_view).scroll_to_line(sel.b.line, true)
		},
		"find-replace:replace": fn() {
			replace("Text", "", fn (text, old, news: str): (str, int) {
				return strings::gsub(text, strings::gsub(old, "%W", "%%%1"), strings::gsub(news, "%%", "%%%%")), 0
			})
		},
		"find-replace:replace-pattern": fn() {
			replace("Pattern", "", fn (text, old, news: str): (str, int) {
				return strings::gsub(text, old, news), 0
			})
		},
		"find-replace:replace-symbol": fn() {
			first := ""
			if doc().has_selection() {
				sel := doc().get_selection().item0
				text := doc().get_text(sel.a.line, sel.a.col, sel.b.line, sel.b.col)
				matches := strings::match(text, config::symbol_pattern)
				if len(matches) > 0 {
					first = matches[0]
				}
			}
			replace("Symbol", first, fn (text, old, news: str): (str, int) {
				n := 0
				res := strings::gsub_fn(text, config::symbol_pattern, fn (sym: str): str |old, news| {
					if old == sym {
						// n = n + 1
						return news
					}
					return sym
				})
				return res, n
			})
		},
	})

}

fn load_commands_root() {
	t := map[str]fn(){
		"root:close": fn() {
			node := rv(cex::root_view).get_active_node()
			node.close_active_view(rv(cex::root_view).root_node)
		},
		"root:switch-to-previous-tab": fn() {
			node := rv(cex::root_view).get_active_node()
			idx := node.get_view_idx(cex::active_view)
			idx = idx - 1
			if idx < 0 { idx = len(node.views)-1 }
			node.set_active_view(node.views[idx])
		},
		"root:switch-to-next-tab": fn() {
			node := rv(cex::root_view).get_active_node()
			idx := node.get_view_idx(cex::active_view)
			idx = idx + 1
			if idx >= len(node.views) { idx = 0 }
			node.set_active_view(node.views[idx])
		},
		"root:move-tab-left": fn() {
			node := rv(cex::root_view).get_active_node()
			idx := node.get_view_idx(cex::active_view)
			if idx > 0 {
				node.views = delete(node.views, idx)
				node.views = insert(node.views, idx - 1, cex::active_view)
			}
		},
		"root:move-tab-right": fn() {
			node := rv(cex::root_view).get_active_node()
			idx := node.get_view_idx(cex::active_view)
			if idx < len(node.views)-1 {
				node.views = delete(node.views, idx)
				node.views = insert(node.views, idx + 1, cex::active_view)
			}
		},
		"root:shrink": fn() {
			node := rv(cex::root_view).get_active_node()
			parent := node.get_parent_node(rv(cex::root_view).root_node)
			n := (parent.a == node)? -0.1 : 0.1
			parent.divider = common::fclamp(parent.divider + n, 0.1, 0.9)
		},
		"root:grow": fn() {
			node := rv(cex::root_view).get_active_node()
			parent := node.get_parent_node(rv(cex::root_view).root_node)
			n := (parent.a == node)? 0.1 : -0.1
			parent.divider = common::fclamp(parent.divider + n, 0.1, 0.9)
		},
	}

	for i := 1; i<=9; i++ {
		t["root:switch-to-tab-" + std::itoa(i)] = fn() |i| {
			node := rv(cex::root_view).get_active_node()
			if i < len(node.views) { node.set_active_view(node.views[i]) }
		}
	}

	for _, dir in []str{ "left", "right", "up", "down" } {
		t["root:split-" + dir] = fn() |dir| {
			node := rv(cex::root_view).get_active_node()
			av := node.active_view
			node.split(dir, null)
			if is_docview(av) {
				rv(cex::root_view).open_doc(dv(av).doc)
			}
		}

		t["root:switch-to-" + dir] = fn() |dir| {
			node := rv(cex::root_view).get_active_node()
			var x, y: real
			if dir == "left" || dir == "right" {
				y = node.position.y + node.size.y / 2
				x = node.position.x + ((dir == "left")? -1.0 : (node.size.x + style::divider_size))
			} else {
				x = node.position.x + node.size.x / 2
				y = node.position.y + ((dir == "up")? -1.0 : (node.size.y + style::divider_size))
			}
			node = rv(cex::root_view).root_node.get_child_overlapping_point(x, y)
			if !node.get_locked_size().item2 {
				cex::set_active_view(node.active_view)
			}
		}
	}

	command::add(fn(): bool {
		node := rv(cex::root_view).get_active_node()
		return !node.get_locked_size().item2
	}, t)
}


fn load_default_commands*() {
	load_commands_doc()
	load_commands_core()
	load_commands_command()
	load_commands_root()
	load_commands_find_replace()
}
