import (
	"env.um"
	"doc.um"
	"docview.um"
	"common.um"
	"cex.um"
	"renderer.um"
	"style.um"
)

type CommandView* = struct{
	dv: docview::DocView;
	suggestion_idx: int;
	suggestions: []cex::Suggestion;
	suggestions_height: real;
	last_change_id: int;
	gutter_width: real;
	gutter_text_brightness: real;
	selection_offset: real;
	state: struct {
		filled: bool;
		submit: cex::SubmitFunc;
		suggest: cex::SuggestFunc;
		cancel: cex::CancelFunc;
	};
	font: str;
	label: str;
}


max_suggestions := 10

fn get_new*(): ^CommandView {
	var self: CommandView
	var sdoc: doc::Doc
	sdoc.singleline = true
	
	self.dv = docview::get_new(&sdoc)
	self.font = "font"
	return &self
}

fn (self: ^CommandView) get_name*(): str {
	return self.dv.view.get_name()
}

fn (self: ^CommandView) get_line_screen_position*(): (real, real) {
	x, _ := self.dv.get_line_screen_position(1)
	_, y := self.dv.view.get_content_offset()
	lh := self.dv.get_line_height()
	return x, y + (self.dv.view.size.y - lh) / 2
}

fn (self: ^CommandView) get_scrollable_size*(): real {
	return 0
}

fn (self: ^CommandView) scroll_to_make_visible*() {
	// -- no-op function to disable this functionality
}

fn (self: ^CommandView) get_text*(): str {
	return self.dv.doc.get_text(1, 1, 1, env::INT_MAX)
}

fn (self: ^CommandView) set_text*(text: str, select: bool = false) {
	self.dv.doc.remove(1, 1, env::INT_MAX, env::INT_MAX)
	self.dv.doc.text_input(text)
	if select {
		self.dv.doc.set_selection(env::INT_MAX, env::INT_MAX, 1, 1)
	}
}

fn (self: ^CommandView) complete*() {
	if len(self.suggestions) > 0 {
		self.set_text(self.suggestions[self.suggestion_idx].text)
	}
}

fn (self: ^CommandView) move_suggestion_idx*(dir: int) {
	n := self.suggestion_idx + dir
	self.suggestion_idx = common::iclamp(n, 0, len(self.suggestions)-1)
	self.complete()
	self.last_change_id = self.dv.doc.get_change_id()
}

fn (self: ^CommandView) is_active_view*(): bool {
	switch av := type(cex::active_view) {
		case ^CommandView: {
			if av == self { return true }
		}
	}
	return false
}

fn (self: ^CommandView) exit*(submitted: bool, inexplicit: bool = false) {
	if self.is_active_view() {
		cex::set_active_view(cex::last_active_view)
	}
	cancel := self.state.cancel
	self.state = {}
	self.dv.doc.reset()
	self.suggestions = {}
	if !submitted && valid(cancel) {
		cancel(!inexplicit)
	}
}

fn (self: ^CommandView) submit*() {
	suggestion := &self.suggestions[self.suggestion_idx]
	text := self.get_text()
	submit := self.state.submit
	self.exit(true)
	submit(text, suggestion)
}

fn (self: ^CommandView) update_suggestions*() {
	t := self.state.suggest(self.get_text())
	res := make([]cex::Suggestion, 0)
	for i, item in t {
		if i == max_suggestions {
			break
		}
		res = append(res, {text: item})
	}
	self.suggestions = res
	self.suggestion_idx = 0
}

fn enter*(self: ^CommandView, text: str, submit: cex::SubmitFunc, suggest: cex::SuggestFunc, cancel: cex::CancelFunc) {
	if self.state.filled {
		return
	}
	self.state = {true, submit, suggest, cancel}
	cex::set_active_view(self)
	self.update_suggestions()
	self.gutter_text_brightness = 100
	self.label = text + ": "
}


fn (self: ^CommandView) get_gutter_width*(): real {
	return self.gutter_width
}

fn (self: ^CommandView) get_suggestion_line_height*(): real {
	return renderer::font_get_height(self.dv.get_font()) + style::padding.y
}


fn (self: ^CommandView) update*() {
	self.dv.update()

	if self.is_active_view() && self.state.filled {
		self.exit(false, true)
	}

	// -- update suggestions if text has changed
	if self.last_change_id != self.dv.doc.get_change_id() {
		self.update_suggestions()
		self.last_change_id = self.dv.doc.get_change_id()
	}

	// -- update gutter text color brightness
	self.dv.view.move_towards(&self.gutter_text_brightness, 0, 0.1)

	// -- update gutter width
	dest := renderer::font_get_width(self.dv.get_font(), self.label) + style::padding.x
	if self.dv.view.size.y <= 0 {
		self.gutter_width = dest
	} else {
		self.dv.view.move_towards(&self.gutter_width, dest)
	}

	// -- update suggestions box height
	lh := self.get_suggestion_line_height()
	dest = len(self.suggestions) * lh
	self.dv.view.move_towards(&self.suggestions_height, dest)

	// -- update suggestion cursor offset
	dest = self.suggestion_idx * self.get_suggestion_line_height()
	self.dv.view.move_towards(&self.selection_offset, dest)

	// -- update size based on whether this is the active_view
	dest = 0
	if self.is_active_view() {
		dest = renderer::font_get_height(style::font) + style::padding.y * 2
	}
	self.dv.view.move_towards(&self.dv.view.size.y, dest)
}


fn (self: ^CommandView) draw_line_highlight*() {
	// -- no-op function to disable this functionality
}

fn (self: ^CommandView) draw_line_gutter*(idx: int, x, y: real) {
	yoffset := self.dv.get_line_text_y_offset()
	pos := self.dv.view.position
	color := common::lerp_color(style::text, style::accent, self.gutter_text_brightness / 100.0)
	cex::push_clip_rect(pos.x, pos.y, self.get_gutter_width(), self.dv.view.size.y)
	x = x + style::padding.x
	renderer::draw_text(self.dv.get_font(), self.label, x, y + yoffset, color)
	cex::pop_clip_rect()
}

fn draw_suggestions_box(self: ^CommandView) {
	lh := self.get_suggestion_line_height()
	dh := style::divider_size
	x, _ := self.get_line_screen_position()
	h := ceil(self.suggestions_height)
	position := self.dv.view.position
	size := self.dv.view.size
	rx, ry, rw, rh := position.x, position.y - h - dh, size.x, h

	// -- draw suggestions background
	if len(self.suggestions) > 0 {
		renderer::fdraw_rect(rx, ry, rw, rh, style::background3)
		renderer::fdraw_rect(rx, ry - dh, rw, dh, style::divider)
		y := position.y - self.selection_offset - dh
		renderer::fdraw_rect(rx, y, rw, lh, style::line_highlight)
	}

	// -- draw suggestion text
	cex::push_clip_rect(rx, ry, rw, rh)
	for i, item^ in self.suggestions {
		color := (i == self.suggestion_idx)? style::accent : style::text
		y := position.y - i * lh - dh
		common::draw_text(self.dv.get_font(), color, item.text, "", x, y, 0, lh)

		if len(item.info) > 0 {
			w := size.x - x - style::padding.x
			common::draw_text(self.dv.get_font(), style::dim, item.info, "right", x, y, w, lh)
		}
	}
	cex::pop_clip_rect()
}

fn (self: ^CommandView) draw*() {
	self.dv.draw()
	cex::defer_draw(fn() |self| {
		draw_suggestions_box(self)
	})
}

