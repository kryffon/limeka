// NOTE this file is here to avoid cyclic imports
// no imports should be here which is not a leaf module
import (
	"system.um"
	"renderer.um"
	"style.um"
	"config.um"
	"common.um"
	"env.um"
	"strings.um"
	"std.um"
)

type (
	LogItem* = struct {
		time: real;
		info, text, at: str;
	}
	
	Suggestion* = struct {
		text, info, command: str;
	}

	SubmitFunc* = fn(text: str, item: ^Suggestion)
	SuggestFunc* = fn(text: str): []Suggestion
	CancelFunc* = fn(a: bool)

	View* = interface {
		get_debug(): str

		try_close(do_close: fn())
		get_name(): str
		get_cursor(): str
		get_scrollable_size(): real
		get_scrollbar_rect(): common::Rect
		scrollbar_overlaps_point(x, y: real): bool
		on_mouse_pressed(button: str, x, y: real, clicks: int): bool
		on_mouse_released(button: str, x, y: real)
		on_mouse_moved(x, y, dx, dy: real)
		on_text_input(text: str)
		on_mouse_wheel(y: real)
		get_content_bounds(): (common::Rect, ^common::Vec2, ^common::Vec2)
		get_content_offset(): (real, real)
		draw_background(color: renderer::Color)
		draw_scrollbar()
	
		update()
		draw()
	}

	Thread* = struct {
		fib: fiber;
		wake, wait: real;
	}
)

var (
	frame_start*: real
	fps*: real
	clip_rect_stack*: []common::Rect
	log_items*: []LogItem
	docs*: []any;
	threads*: []Thread
	project_files*: []system::FileInfo
	project_files_changed*: real
	redraw*: bool = false

	root_view*: View
	command_view*: View
	status_view*: View
	
	active_view*: View
	last_active_view*: View

	temp_uid*: int
	temp_file_prefix*: str
	temp_file_counter*: int
	quit_request*: bool
	window_title*: str
	
	// NOTE this is awful
	count_views_referencing_doc*: fn(doc: any): int
	command_view_enter*: fn(text: str, submit: SubmitFunc, suggest: SuggestFunc, cancel: CancelFunc)
	rv_defer_draw*: fn(f: fn())
	sv_show_message*: fn(icon: str, icon_color: renderer::Color, text: str)
)

fn add_thread*(f: fn(), wait: real) {
	threads = append(threads, {fib: make(fiber, f), wait: wait})
}

fn core_log*(icon: str, icon_color: renderer::Color, text: str): LogItem {
	if len(icon) != 0 {
		sv_show_message(icon, icon_color, text)
		printf("CORE_LOG %v\n", text)
	}

	item := LogItem{time: system::get_time(), text: text}
	log_items = append(log_items, item)
	if len(log_items) > config::max_log_items {
		delete(log_items, 0)
	}
	return item
}

fn log_info*(text: str): LogItem {
	return core_log("i", style::text, text)
}

fn log_quiet*(text: str): LogItem {
	return core_log("", {}, text)
}

fn log_error*(text: str): LogItem {
	return core_log("!", style::accent, text)
}

fn set_active_view*(view: View) {
	if selfhasptr(view) && selfptr(view) != selfptr(active_view) {
		last_active_view = active_view
		active_view = view
	}
}

fn init_tmpfiles() {
	temp_uid = floor(system::get_time() * 1000) % 0xffffffff
	temp_file_prefix = sprintf(".lite_temp_%08x", temp_uid)
	temp_file_counter = 0
}

fn temp_filename*(ext: str = ""): str {
  temp_file_counter = temp_file_counter + 1
  return env::EXEDIR + env::PATHSEP + temp_file_prefix + sprintf("%06x", temp_file_counter) + ext
}

fn delete_temp_files*() {
	for _, fileinfo in system::list_dir(env::EXEDIR) {
		if s,_,ok := strings::find(fileinfo.name, temp_file_prefix, 0, true); ok && s == 1 {
			std::remove(env::EXEDIR + env::PATHSEP + fileinfo.name)
		}
	}
}

fn push_clip_rect*(x, y, w, h: real) {
	cr := clip_rect_stack[len(clip_rect_stack)-1]
	x2, y2, w2, h2 := cr.x, cr.y, cr.w, cr.h
	r, b, r2, b2 := x+w, y+h, x2+w2, y2+h2
	x, y = common::fmax(x, x2), common::fmax(y, y2)
	b, r = common::fmin(b, b2), common::fmin(r, r2)
	w, h = r-x, b-y
	clip_rect_stack = append(clip_rect_stack, { x, y, w, h })
	renderer::set_clip_rect(x, y, w, h)
}

fn pop_clip_rect*() {
	clip_rect_stack = delete(clip_rect_stack, len(clip_rect_stack)-1)
	cr := clip_rect_stack[len(clip_rect_stack)-1]
	x, y, w, h := cr.x, cr.y, cr.w, cr.h
	renderer::set_clip_rect(x, y, w, h)
}

// fn try(fn, ...) {
// 	local err
// 	 ok, res := xpcall(fn, function(msg)
// 		 item := state::core.error("%s", msg)
// 		item.info = debug.traceback(nil, 2):gsub("\t", "")
// 		err = msg
//  }, ...)
// 	if ok {
// 		return true, res
//  }
// 	return false, err
// }

fn init*() {
	init_tmpfiles()
}

// periodic logging
var wake: map[str]real
fn periodic*(tag: str, wait: real, f: fn()) {
	if !validkey(wake, tag) || wake[tag] < system::get_time() {
		printf("[%v]PERIODIC: %s\n", system::get_time(), tag)
		f()
		wake[tag] = system::get_time() + wait
	}
}

fn raw_log*(t: str) {
	printf("[%v] %s\n", system::get_time(), t)
}

