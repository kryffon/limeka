fn f_lower(text: str): str
fn lower*(text: str): str {
	return f_lower(text)
}

fn f_upper(text: str): str
fn upper*(text: str): str {
	return f_upper(text)
}

type Capture = struct {
	s, e: int;
}

fn f_find(s, p: str, iter_offset: int): ([]Capture, int)

// plain search
fn f_search(s, ss: str, init: int): (int, int, bool)
fn search*(s, ss: str, init: int = 0): (int, int, bool) {
	return f_search(s, ss, init)
}

fn find*(text, pattern: str, init: int = 0, plain: bool = false): (int, int, bool) {
	if plain {
		return f_search(text, pattern, init)
	}
	captures := f_find(text, pattern, init).item0
	if len(captures) == 0 {
		return 0, 0, false
	}
	c := captures[0]
	return c.s, c.e, true
}

fn match*(text, pattern: str, init: int = 0): []str {
	captures := f_find(text, pattern, init).item0
	if len(captures) == 0 {
		return []str{}
	} else if len(captures) == 1 {
		c := captures[0]
		return []str{slice(text, c.e, c.e)}
	}
	res := make([]str, 0)
	for i := 1; i < len(captures); i++ {
		c := captures[i]
		res = append(res, slice(text, c.s, c.e))
	}
	return res
}

// if entire == false it only returns captures
fn gmatch*(text, pattern: str, init: int = 0, entire: bool = false): [][]str {
	res := make([][]str, 0)
	captures, iter_offset := f_find(text, pattern, init)
	for len(captures) > 0 {
		start := 0
		if len(captures) > 1 && !entire {
			start = 1
		}
		r := make([]str, 0)
		for i := start; i < len(captures); i++ {
			c := captures[i]
			r = append(r, slice(text, c.s, c.e))
		}
		res = append(res, r)
		captures, iter_offset = f_find(text, pattern, iter_offset)
	}
	return res
}

fn rep*(s: str, n: int, sep: str = ""): str {
	if n <= 1 {
		return s
	}
	if len(s) * n > 1<<30 {
		exit(1, "too much string repeat")
	}
	res := s
	for i := 2; i <= n; i++ {
		res += sep + s
	}
	return res
}

fn sub*(s: str, i: int, j:int = -1): str {
	return slice(s, i, j)
}

fn f_gsub(s, pattern, repl: str): str
fn gsub*(s, pattern, repl: str): str {
	return f_gsub(s, pattern, repl)
}

fn gsub_fn*(text, pattern: str, repl: fn(r: str):str, cap_idx: int = 0): str {
	pos := make([]Capture, 0)
	captures, iter_offset := f_find(text, pattern, 0)
	for len(captures) > 0 {
		pos = append(pos, captures[cap_idx])
		captures, iter_offset = f_find(text, pattern, iter_offset)
	}

	var s: int = 0
	res := ""
	for i in pos {
		var p: Capture = pos[i]
		res += slice(text, s, p.s)
		res += repl(slice(text, p.s, p.e))
		s = p.e
	}
	res += slice(text, s)
	return res
}

fn join*(arr: []str, sep: str = ""): str {
	res := ""
	for i := 0; i<len(arr)-1; i++ {
		res += arr[i] + sep
	}
	res += arr[len(arr)-1]
	return res
}

